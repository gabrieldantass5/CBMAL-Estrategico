# üì∫ Transcri√ß√£o: Customiza√ß√µes do Antigravity - Rules, Workflows e Skills

**Fonte**: [https://www.youtube.com/watch?v=cIR0KS-a33I](https://www.youtube.com/watch?v=cIR0KS-a33I)
**Data da Transcri√ß√£o**: 28/01/2026 19:10:00

---

## ü§ñ AUTO-RESUMO (PONTOS CHAVE)

1. **Rules (Regras)**: S√£o restri√ß√µes manuais que dizem √† IA exatamente como agir ou codar.
   - **Modos de Ativa√ß√£o**:
     - *Manual*: S√≥ quando citada com `@nome_da_regra`.
     - *Always On*: Sempre ativa (ideal para padr√µes fundamentais).
     - *Model Decision*: A IA decide se a regra √© relevante baseado em linguagem natural.
     - *Glob*: Ativa baseada no tipo de arquivo (ex: `*.md` ou `*.py`).
   - **Exemplo**: Uma regra de coment√°rios obrigat√≥rios que garante documenta√ß√£o em toda fun√ß√£o criada.

2. **Workflows (Fluxos de Trabalho)**: Procedimentos passo a passo para tarefas repetitivas.
   - Ativados pelo comando `/nome_da_workflow`.
   - √öteis para automa√ß√µes multi-etapa (ex: limpeza de branches, deploy, revis√£o de PRs).
   - Transformam 10 comandos em apenas 1.

3. **Skills (Habilidades)**: M√≥dulos de treinamento especializado.
   - S√£o pacotes de conhecimento reutiliz√°veis (instru√ß√µes, melhores pr√°ticas e scripts).
   - **Diferencial**: O Antigravity as carrega automaticamente apenas quando detecta que s√£o relevantes para a tarefa atual, economizando contexto.

4. **Hierarquia de Customiza√ß√£o**:
   - **Rules**: Controlam *COMO* a IA escreve/se comporta.
   - **Workflows**: Controlam *O QUE* a IA faz sequencialmente.
   - **Skills**: Fornecem *EXPERTISE* espec√≠fica.

---

## üí° IDEIAS PARA O ECOSSISTEMA CBMAL

1. **Implementar "Always On" Rules para Reda√ß√£o Oficial**:
   - Criar uma regra `sempre_oficial` que garanta que qualquer texto gerado em Markdown para o CBMAL siga o padr√£o de tratamento (Vossa Senhoria, etc) e a estrutura da Portaria 18/2024, sem que voc√™ precise pedir todas as vezes.

2. **Workflow `/validar_sei`**:
   - Criar um workflow que: 1. L√™ a Inbox; 2. Verifica se h√° novos Of√≠cios; 3. Compara o conte√∫do com o Plano de Monitoramento; 4. Gera uma minuta de despacho sugerindo aprova√ß√£o ou ajustes.

3. **Rules de "Glob" para Markdown**:
   - Configurar uma regra que se ativa apenas em arquivos `.md` dentro da pasta `01_Gestao_Estrategica`, for√ßando o uso de refer√™ncias cruzadas com o PDI (Plano de Desenvolvimento Institucional).

4. **Skill de "Auditoria de Termos Militares"**:
   - Como o Antigravity carrega skills sob demanda, podemos ter uma skill focada apenas em jarg√£o e siglas do CBMAL. Ela s√≥ seria ativada quando detectasse que estamos escrevendo um documento oficial, garantindo que "BM" seja usado em vez de "bombeiro" onde for tecnicamente exigido.

---

## üìù CONTE√öDO √çNTEGRO

Hey everyone, today I'm diving into anti-gravity customizations, the powerful features that let you personalize your AI coding agent to work exactly the way you want. We're talking rules, workflows, and skills that can completely transform how you code. Now, if you don't know what Anti-Gravity is, it's Google's AI-powered coding agent. And getting started is super simple. Just head over to anti-gravity.google and download it with one click. That's it, you're ready to go. Alright, so rules, they're basically constraints. You manually write that tell your AI agent exactly how to code. And the cool part, you can set them up globally for all your projects, or just locally for specific ones. Each rule file can be up to twelve thousand characters, which is plenty of space to define your coding standards. So let me show you how to create your very first rule. Let's jump in. Click the workspace button here and enter your rule name. In my case, I'm going to create a comments rule. Now, see these options for activation mode? This is really important because it controls when your rule actually applies. There are 4 activation modes you can choose from. first, manual. This means the rule only activates when you specifically mention it using the at symbol in the agent's input box. Think of it like calling the rule by name when you need it. second, Always On. Pretty straightforward. This rule is always applied to everything the agent does, perfect for your core coding standards that should never be ignored. third, Model Decision. This one's smart. You give the agent a natural language description of when to use the rule, and it decides automatically based on context. So if you say apply this when working with authentication, the agent figures out when that's relevant. And 4th, glob. This uses file patterns. For example, you can say only apply this rule to JavaScript files using star.js, or apply to all TypeScript files in the source folder using patterns like source slash star star slash star dot ts, super useful for project-specific standards. I'm gonna choose Always On because I'm creating a comments rule, and I want the agent to add comments to every piece of code it writes, no exceptions. This way, I don't have to remember to ask for comments every single time, the agent will just do it automatically. So here's what I'm putting in my comments rule. I'm telling the agent to add comments that explain why the code exists, not just what it does. Also include any tricky logic and to-do items if needed. And for functions, always use JSTOCK format with the description, parameters, and return values clearly documented. This keeps everything clean and professional. I'm gonna ask the AI agent to create a discount function, and see if it automatically follows our comments rule. Look at this! The agent automatically added JSTOCK comments, explaining what the function does, why it exists, and even documented the tricky logic about capping discounts to prevent negative prices. Plus, it added inline comments for the edge cases and rounding. All because of our rule! We didn't have to ask for any of this, it just happened automatically. These comments are super useful because months later, you or your team can instantly understand why the code exists and what edge cases it handles without digging through the actual implementation. All right, so that's rules. They control how your agent codes. But what about automating repetitive tasks? That's where workflows come in. And speaking of automation that saves you time, let us talk about today's sponsor, who automates one of the most tedious parts of development, testing. This video is sponsored by Test Sprite, an AI testing agent for modern developers. It automatically generates tests, runs them, and fixes issues right in your IDE. Test Sprite's MCP server connects to your IDE and turns hours of testing work into an automated workflow. Start with the Quick Install option. first, you'll need to create an API key, then you can install the MCP server in AI-powered IDEs like Cursor, Cloud Code, and others. If you're using Cursor, it's just one click to add the MCP server. Once installed, you'll see all the available tools that will execute during your workflow. Here's my application that I'm going to test. Simply copy the prompt and paste it into the chat. TestSprite's tools will now execute one by one. first, configure your testing setup. Choose your testing mode, either backend or frontend. Then select your scope, such as code base. If your application requires authentication, you can add test credentials. Next, specify your port number and upload any product specification documents, like a project info markdown file. Now you can see TestSprite created a new folder. In here, there's a code summary JSON file. This has fully mapped out your entire text stack and captured every feature in your app. TestSprite has also auto-generated a front-end test plan file that contains comprehensive test cases, each categorized and assigned a priority. Over in the TestSprite dashboard, you can see tests running in real time. Some passing, some failing, others in progress. And here's what's really useful. It includes video recordings and gives you the actual automation code so you can rerun these tests whenever you need. For the failing test cases, it even displays the exact reason why they failed. Once testing is complete, it generates an overall report with the pass rate. And here's the best part. Using this report, Cursor can automatically fix all the issues from the failed tests. Check out the link in the description to install TestSprite's MCP server and start testing smarter, not harder. So workflows are basically step-by-step procedures you want the agent to follow for repetitive tasks. Think of them like saved multi-step commands. While rules tell the agent how to write code, workflows tell it what to do, like deploying to production, cleaning up old Git branches, or responding to pull request comments. The cool part? You just type slash and the workflow name, and the agent executes all the steps automatically. Let's create our first workflow. Click the 3 dots again, go to Customizations, and this time select Workflows. Now click the Workspace button to create a workflow for this project. I'm going to create a branch cleanup workflow that automatically removes merged Git branches. Here's what my branch cleanup workflow looks like. first, I add a description explaining what this workflow does. It cleans up merged branches to keep the repo tidy. Then I list out all the steps the agent should follow. It starts by fetching the latest changes, switches to main, pulls the latest code, then lists all the merged branches, After that, it identifies which branches are safe to delete, excluding protected branches like main, develop, and staging. It asks me to confirm which ones to delete, then removes them both locally and from the remote repository. Finally, it runs garbage collection to free up space, and shows me a summary. So basically, what would normally take me ten manual commands is now just one workflow command. After pasting this in, just hit save and close. That's it. Your workflow is now ready to use. So I've created 2 branches. One is the about branch containing the about page, and another is the contact page branch with the contact UI. Both are committed. Now I'm on the main branch. What I'll do is merge the about branch here. Now see the about folder has appeared. We can leave the contact page branch as is for now. Now let's run the cleanup branch workflow. I'll type slash clean up branches and hit enter. Now it started working. Give it a few seconds. Look at this, it identified the safe to delete branch. Since we merged the about branch, it's saying the code is merged and safe to delete, and it's showing both the local and remote versions. If you want to confirm and delete both, just reply with yes or all. If you only want to delete the local branch and keep the remote, you can mention that too. It is completely flexible based on what you need. Now see, the about branch is deleted, it's not showing anymore. The workflow cleaned it up automatically, both locally and from the remote. So this is just one example of how to use workflows. Now, there's one more powerful feature called skills. While rules control how your agent codes, workflows handle step-by-step tasks, skills are like specialized training modules that give your agent expertise in specific areas, and the agent automatically loads them only when they're relevant to your current task. Skills are reusable packages of knowledge that extend what the agent can do, Each skill contains instructions on how to approach a specific type of task, best practices and conventions to follow, and optional scripts and resources the agent can use. This is the folder structure you need to follow for creating skills. And if you want to deep dive into skills, I highly recommend checking out the video I already posted about this. Just watch that one. And here's a cool thing. Skills aren't just for anti-gravity, they're actually supported by all popular IDEs, so you can use them anywhere. I'm going to create my first skill, a Next.js review skill, I'll paste my instructions here that tell the agent to focus only on critical issues like TypeScript types, performance problems, security vulnerabilities, and proper app router patterns. The skill breaks down what to check in priority order, from breaking issues to minor improvements, and keeps feedback short and actionable. Now I'll ask the agent to review my Next.js code. After I submit, watch this. The agent looks at all available skills, reads their names and descriptions, and automatically decides which one is relevant to my task. In this case, it identified that I need the Next.js review skill and loaded it. The smart part is it only loads skills when they're actually needed, so it doesn't waste context or slow things down. Now look at this. It's showing exactly what issues are there, formatted based on the pattern we defined in our skill. It's not just pointing out problems, it's also giving suggestions on how to fix each issue. And here's what I really like. It's listing the project strengths too, not just the negative stuff. It's acknowledging what's already good in the code. Finally, it's even asking if I want it to apply the fixes for me automatically. That's awesome. It's not just reviewing, it's ready to take action. Alright guys, so that's rules, workflows, and skills in a nutshell. Rules keep your code consistent automatically, workflows automate your repetitive tasks with one command, and skills give your agent specialized expertise that loads exactly when you need it. Honestly, once you start using these 3 features together, your productivity is going to skyrocket. And hey, all the resources, code examples, and links are in the description below. So grab those and start building your own rules and workflows today. If you found this helpful, smash that like button and drop a comment telling me what rule or workflow you're going to create first. And if you want more deep dives on AI coding tools, hit that subscribe button because I'm dropping videos like this every week. All right, catch you in the next one. Peace.

---
*Gerado automaticamente pelo Cockpit Estrat√©gico CBMAL.*
